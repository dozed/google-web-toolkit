/*
 * Copyright 2010 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.gwt.dev.shell.rewrite;

import static com.google.gwt.dev.shell.rewrite.HostedModeClassRewriter.CANONICAL_FIELD;
import static com.google.gwt.dev.shell.rewrite.HostedModeClassRewriter.REWRAP_METHOD;
import static com.google.gwt.dev.shell.rewrite.HostedModeClassRewriter.SINGLE_JSO_IMPL_ADJUNCT_SUFFIX;
import static com.google.gwt.dev.shell.rewrite.HostedModeClassRewriter.SINGLE_JSO_IMPL_FIELD;

import com.google.gwt.dev.shell.JsValueGlue;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Utility methods that are called by code generated by
 * {@link WriteSingleJsoSupportCode}.
 */
public class SingleJsoImplSupport {

  /**
   * Stash a reference to the JavaScriptObject Class object.
   */
  private static final ThreadLocal<Class<?>> JSO_CLASS_OBJECT = new ThreadLocal<Class<?>>();

  /**
   * Called from JsValueGlue to ensure that a JSO instance can be cast to the
   * desired type. If the desired type is a regular JSO subclass, this is a
   * simple rewrap call. Otherwise, assume that it's a SingleJsoImpl interface
   * type and use {@link #cast(Object, Class, Class)}.
   */
  public static Object cast(Object o, Class<?> jsoOrIntfType) {
    assert o != null : "o is null";
    assert jsoOrIntfType != Object.class : "Not expecting Object";

    if (jsoOrIntfType.isInterface()) {
      // Casting to an interface type
      Class<?> targetJsoType = getTargetJsoType(jsoOrIntfType);

      checkTarget(jsoOrIntfType, targetJsoType);

      // Let the no-implementing-type code in cast(3) handle the error
      return rewrap(targetJsoType, o);
    }

    if (getJsoClass(o).isAssignableFrom(jsoOrIntfType)) {
      // A JSO type
      return rewrap(jsoOrIntfType, o);
    }

    // Something else, let the call-site hit CCE
    return o;
  }

  /**
   * Called by synthetic code to cast an object <code>o</code> to some concrete
   * type that implements the interface <code>intfType</code>. If a
   * JavaScriptObject subtype has been loaded that implements the interface,
   * that type will be provided in <code>targetJsoType</code>.
   * 
   * @return an object that implements <code>intfType</code>
   * @throws ClassCastException if <code>o</code> is a JSO subtype and there is
   *           no SingleJsoImpl type for <code>intfType</code>
   */
  public static Object cast(Object o, Class<?> intfType, Class<?> targetJsoType) {
    if (o == null || intfType.isInstance(o) || !getJsoClass(o).isInstance(o)) {
      // Let class cast exception happen at callsite
      return o;
    }

    checkTarget(intfType, targetJsoType);

    return rewrap(targetJsoType, o);
  }

  /**
   * Called by synthetic code when the object on the stack might be a JSO
   * wrapper and we want the canonical object.
   */
  public static Object ensureCanonical(Object o) {
    if (o == null) {
      return null;
    }

    Class<?> jsoClass = getJsoClass(o);
    if (jsoClass.isInstance(o)) {
      Exception ex;
      try {
        return jsoClass.getField(CANONICAL_FIELD).get(o);
      } catch (IllegalArgumentException e) {
        ex = e;
      } catch (SecurityException e) {
        ex = e;
      } catch (IllegalAccessException e) {
        ex = e;
      } catch (NoSuchFieldException e) {
        ex = e;
      }
      throw new RuntimeException("Unable to determine canonical object", ex);
    }

    return o;
  }

  /**
   * Returns the JSO implementation type declared on the interface via a
   * SingleJsoImpl annotation.
   */
  @SuppressWarnings("unchecked")
  public static Class<?> getDeclaredSingleJsoImplType(Class<?> intfType) {
    Exception ex;
    try {
      Class singleJsoImplType = intfType.getClassLoader().loadClass(
          "com.google.gwt.core.client.SingleJsoImpl");
      Object annotation = intfType.getAnnotation(singleJsoImplType);
      if (annotation != null) {
        Method m = singleJsoImplType.getMethod("value");
        Class<?> value = (Class<?>) m.invoke(annotation);
        return value;
      }

      // Try the by-name annotation
      singleJsoImplType = intfType.getClassLoader().loadClass(
          "com.google.gwt.core.client.SingleJsoImplName");
      annotation = intfType.getAnnotation(singleJsoImplType);
      if (annotation != null) {
        Method m = singleJsoImplType.getMethod("value");
        String name = (String) m.invoke(annotation);

        return Class.forName(name, true, intfType.getClassLoader());
      }

      return null;
    } catch (ClassNotFoundException e) {
      ex = e;
    } catch (IllegalArgumentException e) {
      ex = e;
    } catch (IllegalAccessException e) {
      ex = e;
    } catch (InvocationTargetException e) {
      ex = e;
    } catch (SecurityException e) {
      ex = e;
    } catch (NoSuchMethodException e) {
      ex = e;
    }
    throw new RuntimeException("Unable to determine SingleJsoImpl type", ex);
  }

  /**
   * Called by synthetic code to implement instanceof tests.
   * 
   * @param o the object to test
   * @param intf the interface type that <code>o</code> is being tested against
   * @param implJsoType the JavaScriptObject subtype that implements
   *          <code>intf</code> if it has been loaded
   * @return <code>true</code> if <code>o</code> implements <code>intf</code> or
   *         if <code>o</code> is a JSO and some JSO type that implements
   *         <code>intf</code> has been loaded
   */
  public static boolean instanceOf(Object o, Class<?> intf, Class<?> implJsoType) {
    return intf.isInstance(o)
        || (implJsoType != null && getJsoClass(o).isInstance(o));
  }

  /**
   * Throw a specialized ClassCastException if <code>targetJsoType</code> is
   * null.
   */
  private static void checkTarget(Class<?> intfType, Class<?> targetJsoType) {
    if (targetJsoType == null) {
      throw new ClassCastException(
          "There is no known JavaScriptObject subtype that implements "
              + intfType.getCanonicalName()
              + ". Fix by adding an @SingleJsoImpl annotation to "
              + intfType.getSimpleName()
              + " or by referencing the concrete JSO type.");
    }
  }

  /**
   * Load the JavaScriptObject Class object from a client object's isolated
   * ClassLoader.
   */
  private static Class<?> getJsoClass(Object jso) {
    Class<?> toReturn = JSO_CLASS_OBJECT.get();
    if (toReturn != null) {
      return toReturn;
    }
    try {
      toReturn = jso.getClass().getClassLoader().loadClass(
          JsValueGlue.JSO_CLASS);
    } catch (ClassNotFoundException e) {
      throw new RuntimeException("No JavaScriptObject class", e);
    }
    JSO_CLASS_OBJECT.set(toReturn);
    return toReturn;
  }

  private static Class<?> getTargetJsoType(Class<?> intfType) {
    Field f;
    Exception ex;
    try {
      intfType = intfType.getClassLoader().loadClass(
          intfType.getName() + SINGLE_JSO_IMPL_ADJUNCT_SUFFIX);
      f = intfType.getField(SINGLE_JSO_IMPL_FIELD);
      return (Class<?>) f.get(null);
    } catch (SecurityException e) {
      ex = e;
    } catch (NoSuchFieldException e) {
      ex = e;
    } catch (IllegalArgumentException e) {
      ex = e;
    } catch (IllegalAccessException e) {
      ex = e;
    } catch (ClassNotFoundException e) {
      ex = e;
    }
    throw new RuntimeException("Unable to query singleJsoImpl type", ex);
  }

  /**
   * Reflectively invoke a JSO subtype's rewrap method to create a new wrapper
   * instance for a JavaScriptObject.
   * 
   * @param jsoClass the desired wrapper type
   * @param jso a JavaScriptObject
   * @return a JavaScriptObject wrapper that encloses <code>jso</code>'s
   *         canonical JSO identity
   */
  private static Object rewrap(Class<?> jsoClass, Object jso) {
    Method m;
    Exception ex;
    try {
      m = jsoClass.getMethod(REWRAP_METHOD, getJsoClass(jsoClass));
      return m.invoke(null, jso);
    } catch (NoSuchMethodException e) {
      throw new RuntimeException("Missing expected synthetic method", e);
    } catch (SecurityException e) {
      ex = e;
    } catch (IllegalArgumentException e) {
      ex = e;
    } catch (IllegalAccessException e) {
      ex = e;
    } catch (InvocationTargetException e) {
      ex = e;
    }
    throw new RuntimeException(ex);
  }

  /**
   * Utility class.
   */
  private SingleJsoImplSupport() {
  }
}
